package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/rgolang/rgo/ast"
	"github.com/rgolang/rgo/llvm"
)

type TestCase struct {
	FunctionName string
	Input        string
	Expected     string
}

const astTestFileTemplate = `
func {{ .FunctionName }}Ast(t *testing.T) {
	input := {{.Input}}
	b, err := ToAst(strings.NewReader(input))
	require.NoError(t, err)
	actual := string(b)

	expected := {{.Expected}}
	require.JSONEq(t, expected, actual, fmt.Sprintf("got: %v", actual))
}
`
const irTestFileTemplate = `
func {{ .FunctionName }}Codegen(t *testing.T) {
	input := {{.Input}}
	actual, err := GenerateIR(strings.NewReader(input))
	require.NoError(t, err)
	expected := {{.Expected}}
	require.Equal(t, strings.TrimSpace(expected), strings.TrimSpace(actual), fmt.Sprintf("got: %v", actual))
}
`

type Template struct {
	InputFile string
	OuputFile string
	Header    string
	Template  string
	Expected  func(input []byte) ([]byte, error)
}

func main() {
	flag.Parse()
	args := flag.Args()

	if len(args) < 1 {
		fmt.Println("Usage: go run testgen/main.go [folder]")
		os.Exit(1)
	}

	templates := []Template{
		{
			OuputFile: "./ast/ast_parser_gen_test.go",
			Header: `// Code generated by testgen. DO NOT EDIT.
package ast

import (
	"fmt"
	"testing"
	"strings"

	"github.com/stretchr/testify/require"
)
			`,
			Template: astTestFileTemplate,
			Expected: func(input []byte) ([]byte, error) {
				b, err := ast.ToAst(strings.NewReader(string(input)))
				if err != nil {
					return nil, fmt.Errorf("error parsing ast: %w", err)
				}
				return b, nil
			},
		},
		{
			OuputFile: "./llvm/llvm_gen_test.go",
			Header: `// Code generated by testgen. DO NOT EDIT.
package llvm

import (
	"fmt"
	"testing"
	"strings"

	"github.com/stretchr/testify/require"
)
			`,
			Template: irTestFileTemplate,
			Expected: func(input []byte) ([]byte, error) {
				b, err := llvm.GenerateIR(strings.NewReader(string(input)))
				if err != nil {
					return nil, fmt.Errorf("error generating llvm: %w", err)
				}
				return []byte(b), nil
			},
		},
	}

	for tid, t := range templates {
		outFile, err := os.OpenFile(t.OuputFile, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
		if err != nil {
			log.Fatalf("Error creating file: %v", err)
		}
		defer outFile.Close()

		_, err = outFile.WriteString(t.Header)
		if err != nil {
			fmt.Println("Error writing to file:", err)
			return
		}

		folderPath := args[0]
		err = filepath.Walk(folderPath, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}

			if !info.IsDir() && filepath.Ext(path) == ".rgo" && strings.HasPrefix(filepath.Base(path), "test_") {
				fmt.Printf("Template %d handling file: %s\n", tid, path)

				// Read the file
				input, err := os.ReadFile(path)
				if err != nil {
					return fmt.Errorf("error reading file %s: %w", path, err)
				}

				tmpl, err := template.New("test").Parse(t.Template)
				if err != nil {
					return err
				}

				b, err := t.Expected(input)
				if err != nil {
					return err
				}

				// Execute the template and write to the file
				err = tmpl.Execute(outFile, TestCase{
					FunctionName: toPascalCase(strings.TrimSuffix(filepath.Base(path), ".rgo")),
					Input:        "`\n" + string(input) + "\n`",
					Expected:     "`\n" + string(b) + "\n`",
				})
				if err != nil {
					panic(err)
				}
			}

			return nil
		})
		if err != nil {
			fmt.Printf("Error scanning the folder: %s\n", err)
			os.Exit(1)
		}
	}
}

func toPascalCase(s string) string {
	// Split the string by underscores
	parts := strings.Split(s, "_")

	// Capitalize the first letter of each part and concatenate
	var camelCase string
	for _, part := range parts {
		if part != "" {
			// Capitalize the first letter of part
			camelCase += strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return camelCase
}
